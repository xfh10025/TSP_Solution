## TSP问题

TSP文件中包含蛮力法，回溯法，分支限界法。通过注释将代码区域分开

蛮力法采用全排列比较，回溯法是深搜剪枝，比较容易



分支限界法 首先创建了一个Node类，记录lb，当前所在顶点，该节点走过的路径



lb计算相比其他要麻烦，初始的lb为邻接矩阵的每行选择最小的两个顶点a<sub>i</sub><sub>Min1</sub>和a<sub>i</sub><sub>Min2</sub> 
$$
lb = \frac{\sum_i^n a_{iMin1}+a_{iMin2}}{2}
$$
之后的lb计算就将每个路径经过的节点替换进（1），然后再选择除该点外的最小值，例:0->2->3的lb计算（假设0,1,2,3,4为顶点）
$$
lb = \frac{(a_{02}+a_{0min}) + (a_{1Min1}+a_{1Min2})+(a_{02}+a_{23})+(a_{23}+a_{3min})+(a_{4Min1}+a_{4Min2})}{2}
$$


其中a<sub>iMin</sub>表示第i行除了经过的节点外最小的值，a<sub>iMin1</sub>和a<sub>iMin2</sub>表示没有经过该行的节点，所以继续选择最小的两个点



#### 动态规划解决TSP问题

代码在tsp_dp文件中，其中使用了MatrixPrint，打印了dp数组

动态规划法tsp问题实现主要采用二进制表示的方式，比如4的二进制是100，就相当于3节点选了，而2和1节点没选（选择0为出发点），所以用二进制表示的dp数组横轴长这样（以0,1,2,3点为例）：

```
0   1       2       3       4      5       6        7
0   001     010     011     100    101     110      111
    {1}     {2} 	{1,2} 	{3}  	{1,3}  {2,3}	{1,2,3}
```

这样填表就可以

位运算中有些代码不容易理解，如

```java
if(((j >> (i-1)) & 1) == 0) // 表示未被选
  /*
  i 表示的是第i行
  如 i = 2时，填第5列表时，j = 5 = 101
  那我将j左移i-1位就变成了10，此时进行&运算，就知道i并没有选中
  */
```

```java
int num = map[i][k] + dp[k][j^(1<<(k-1))];
/*
这里进行异或运算，找的是选择第k号节点后的子问题
如 对于j = 6 {2,3} ,i = 1
此时的问题为dp(1,{2,3})，那么他的值就是子问题map[1][2] + dp[2,{3}]和map[1][3] + dp[3,{2}]中的最小值

拿第二个子问题map[1][3] + dp[3,{2}]来看
在二进制中看来，{2,3}表示二进制的110,3表示二进制的100，那么当我选择将110的高位1变为0，就成了010，就成了2，所以只需将110和100进行异或，就可以，而100表示的是4 = 2^(3-1)
*/
```









